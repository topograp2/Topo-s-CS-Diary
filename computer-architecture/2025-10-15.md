# ✍️ 2025-10-15 공부한 내용
- **명령어(instruction)** : 컴퓨터 언어에서 단어
    - 사람이 프로그램을 작성할 때 사용하는 형태
    - 컴퓨터가 직접 읽을 수 있는 형태
- **명령어 집합(instruction set) :** 명령어의 집합

앞으로 사용할 명령어 집합 - **RISC-V**

- 다른 명령어 집합
    - MIPS
    - Intel x86
- 이 중 하나만 배워도 다른 언어에 쉽게 익숙해질 수 있음

**하드웨어의 간결성**

- 모든 컴퓨터가 같은 기본 원리 위에 구축된 하드웨어 기술로 만들어짐
- 모든 컴퓨터가 제공해야 하는 기본적인 기능은 몇 가지 안됨
- 최소 비용과 에너지로 하드웨어/컴파일러 제작이 쉽고 최대 성능 추구

## 하드웨어 연산

모든 컴퓨터는 산술연산이 가능해야 한다.

```
add a, b, c
```

- RISC-V 어셈블리 언어로 변수 b와 c의 합을 a에 넣으라고 지시하는 명령어

RISC-V 산술 명령어는 **한 종류의 연산**만 지시하고 **항상 변수 3개**를 가짐

만약에 b, c, d, e의 합을 a에 넣고 싶다면?

```
add a, b, c // b와 c의 합을 a에 넣음
add a, a, d // b와 c, d의 합을 a에 넣음
add a, a, e // b와 c, d, e의 합을 a에 넣음
```

- 위와 같이 3개의 명령어를 이용하여 해당 합을 구할 수 있다.
- 주석 : ‘//’을 이용하고 줄이 끝날 경우 주석도 끝난다.
- 명령어 : 한 줄에 명령어 하나만 쓸 수 있음
- 모든 명령어가 피 연산자를 3개씩 갖도록 제한 = 하드웨어 단순하게 하자!

**설계 원칙 1: 간단하기 위해서는 규칙적인 것이 좋다.**

## 피연산자

산술 명령어의 피연산자에는 제약이 있다.

- register라는 직접 구현된 특수 위치 몇 곳에 있는 것만 사용 가능하다.
- RISC-V 구조에서 레지스터 크기는 32bit이고, 32비트가 한 덩어리로 처리되는 경우가 많은데 이 덩어리를 word라고 한다 (64비트는 더블워드)
- 레지스터의 개수는 한정되어 있다.
    - 왜 한정 시켰을까?
    - **설계 원칙 2: 작은 것이 더 빠르다**
    - 레지스터가 아주 많아지면 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클 시간이 길어진다.

### 메모리 피연산자

단순 변수 외에도 배열이나 구조체 같은 자료구조는 어떻게 표현되는지 알아보자.

- 프로세서 : 소량의 데이터만을 레지스터에 저장
- 컴퓨터 메모리 : 수십억 개의 데이터를 저장할 수 있다.
    - 배열이나 구조체를 메모리에 보관!

앞서 살펴본 산술연산은 레지스터에서만 실행되어서 메모리와 레지스터 간에 데이터를 주고받는 명령어가 필요하다.

- 데이터 전송 명령어 ( data transfer instruction ) : 메모리와 레지스터 간에 데이터를 주고받는 명령어
    - 메모리에 기억된 데이터에 접근하려면 명령어가 **메모리 주소를 지정**해야 한다.

메모리는 주소가 인덱스 역할을 하는 1차원 배열로, 0부터 시작한다.

- **적재(load) : 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령**
    - 구성 요소 : 연산자 이름, 메모리에서 읽어 온 값을 저장할 레지스터, 메모리 접근에 사용할 상수와 레지스터
    - 메모리 주소= 명령어의 상수 부분 + 두 번째 레지스터 값\
    - 명령어 : lw

프로그램 상에서 바이트(8비트)를 주로 사용한다. 워드는 32비트이므로 4바이트에 해당하고 **연속된 워드의 주소는 4씩 차이**가 난다.

- 리틀 엔디안 : 제일 오른쪽, 즉 최하위 바이트 주소를 워드 주소로 사용
    - RISC-V
- 빅 엔디안 : 제일 왼쪽, 즉 최상위 바이트 주소를 워드 주소로 사용

그러므로 워드 배열 A의 시작 주소가 x22에 기억되어 있고 A[8]의 주소를 구하고 싶으면?

- x22 + 4 * 8

**저장(store) : 레지스터 내용을 메모리로 복사**

- 구성 요소 : 연산자 이름, 저장할 데이터를 갖고 있는 레지스터, 베이스 레지스타, 배열 원소 선택에 사용할 변위
- 주소의 일부는 상수 형태로 명령어에 포함되어 있고 일부는 레지스터에 기억되어 있음
- 명령어 : sw

레지스터보다 프로그램에서 사용하는 변수가 더 많으면 자주 사용하는 변수는 레지스터에 최대한 많이 넣고 나머지 변수는 메모리에 저장(스필링)했다가 필요할 때 레지스터에 넣음

- 메모리에 있을 때보다 레지스터에 있을  때 더 빨리 접근 가능
- 레지스터에 저장된 데이터가 메모리 데이터보다 사용하기 편리

→ 레지스터를 충분히 제공하고 컴파일러가 레지스터를 효율적으로 사용할 수 있게 해야 함.

### 상수 또는 수치 피연산자

프로그램이 적재될 때 상수가 메모리에 넣어지고, 상수를 사용하려면 메모리에서 상수를 읽어와야 한다.

```
lw x9, AddrConstant4(x3)
add x22, x22, x9
```

- x3  + AddrConstant4가 상수 4가 저장되어 있는 메모리 주소라고 가정
- 피연산자 중 하나가 상수인 산술 연산 명령어를 제공하면 적재명령을 사용하지 않을 수 있음 ( 수치 피연산자)
    - ex) 명령어 : addi

```
addi x22, x22, 4 // x22 = x22 + 4
```

- 상수 필드를 갖는 산술 명령어 사용 시 메모리에서 상수를 가져오는 것보다 연산이 빠르고 에너지를 덜 소모함
- 0은 명령어에 변형 제공하여 단순화 가능
    - sub x22, 0, x22 → 부호 변경
    - x0은 값이 0으로 고정 → 자주 쓰이는 것을 빠르게

 ( ~ p.88)
 
# 🙋 정리 및 소감
- 컴퓨터구조 수강 시 공부한 기억이 잘 나는 부분이라 가볍고 짧게 복습해도 될 거 같다.
